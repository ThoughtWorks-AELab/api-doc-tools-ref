# API Documentation Tool Reference Implementation

No matter how far down the HATEOAS rabbit hole you go, you will never have a perfectly
self describing API that every Alice, Bob, and Casey can integrate with automagically.
API documentation is good. If anyone ever tries to quote the Agile Manifesto at you,
quote it right back at them: "That is, while there is value in the items on
the right, we value the items on the left more."

Given that you agree API docs are important, the question remains of how to make them
accurate and useful. 2 techniques are often discussed: _spec-first_, wherein an API
specification is authored and then scaffold code is generated from it and the business
logic filled in; and _code-first_, where you generate a specification from the code as
it exists. We argue that neither of these works particularly well; editing auto-generated
code is a pain to deal with in terms of source control and not accidentally clobbering
your hand-authored additions, while the code first approach results in littering the
codebase with line-noise annotations and sometimes even changing code structure to produce
the desired documentation.

The model illustrated here is spec-and-then-code. The specification is authored, and then
automated test scaffolding allows the developer to validate that the service as written
implements the specified interface. This allows nice human readable information and
descriptions to be confined to the specification document, while also avoiding SOAP-esque
src-gen hell. In a sense this can be viewed as an extension of the BDD mentality to an
API-centric model. If you want to call it spec-driven development that's cool too.

## What's here

This reference implementation is a pretty bog-standard Spring Boot service that tracks
users and their posts, and stores them in an in-memory DB. `SwaggerDocTest.java` is where
the spec-first goodness lives. It uses the additional Spring config in `SwaggerConfiguration`
to add swagger-ui to the app, retrieves the exposed spec as generated by swagger-parser, and
uses assertj-swagger to test that the actual semantically matches the expected. With this
setup your deployable code doesn't require any knowledge of Swagger's existence, which makes
artifacts smaller and code less cluttered with functionality-free noise.

Additionally there's a very simple bash script to tie publishing the spec to SwaggerHub into
a CD pipeline. SwaggerHub is pretty nice in terms of making it easy to publish your spec,
and we've had success using it as an internal developer doc hub across multiple environments.

## What's next?

Writing Swagger/OpenAPI specs by hand is tedious. The work is repetitive, rote, and leaves
a lot of room for manual error during authoring. Time-permitting there's an interesting
possibiity in creating a tool that makes authoring these specs easier/faster.
